name: Sync Release
on:
  push:
    tags: ['v*']  # 标签触发（如 v1.0.0）
  workflow_dispatch:  # 手动触发
    inputs:
      version:
        description: '版本号（必须带 v 前缀，如 v1.0.0）'
        required: true
        default: 'v1.0.0'

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      # 1. 检出源仓库代码
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 确保获取标签历史

      # 2. 提取并校验版本号（兼容手动/标签触发）
      - name: 提取版本号
        id: ver
        run: |
          # 手动触发：取输入值；标签触发：取标签名
          VERSION=${{ github.event.inputs.version || github.ref_name }}
          # 强制校验 v 前缀
          if [[ "$VERSION" != v* ]]; then
            echo "::error::版本号必须以 v 开头（如 v1.0.0）"
            exit 1
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      # 3. 打包仓库（单行命令 + bash 确保参数正确）
      - name: 打包内容
        run: zip -r "release-${{ steps.ver.outputs.VERSION }}.zip" . -x "*.git*" ".github/" "release-*.zip"
        shell: bash  # 强制用 bash 解析参数，避免续行问题

      # 4. 发布到源仓库的 Releases（自动授权）
      - name: 发布到源仓库
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.VERSION }}
          files: "release-${{ steps.ver.outputs.VERSION }}.zip"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 源仓库内置 Token

      # 5. 跨仓库同步到目标仓库（显式 PAT 认证）
      - name: 同步到目标仓库
        uses: actions/github-script@v7
        env:
          TARGET_OWNER: "mzsy123"            # 替换为目标仓库所有者（如 GitHub 用户名）
          TARGET_REPO: "mzsy123.github.io"   # 替换为目标仓库名称
          TAG: ${{ steps.ver.outputs.VERSION }}
          ASSET_PATH: "release-${{ steps.ver.outputs.VERSION }}.zip"
        with:
          github-token: ${{ secrets.TARGET_REPO_PAT }}  # 需提前配置的 PAT（安全存储）
          script: |
            // 解构环境变量
            const { TARGET_OWNER, TARGET_REPO, TAG, ASSET_PATH } = process.env;
            const octokit = github.rest;  // 内置 octokit，自动使用传入的 PAT 认证

            // ① 尝试获取已有 Release，不存在则创建
            let release;
            try {
              release = await octokit.repos.getReleaseByTag({
                owner: TARGET_OWNER,
                repo: TARGET_REPO,
                tag: TAG
              });
            } catch (err) {
              if (err.status === 404) {
                // 创建新 Release
                release = await octokit.repos.createRelease({
                  owner: TARGET_OWNER,
                  repo: TARGET_REPO,
                  tag_name: TAG,
                  name: `Sync from Source: ${TAG}`,
                  body: "此版本自动从源仓库同步发布",
                  draft: false,
                  prerelease: false
                });
              } else {
                core.setFailed(`Release 操作失败：${err.message}`);
                return;
              }
            }

            // ② 上传资产到目标仓库
            try {
              const fileContent = await require('fs').promises.readFile(ASSET_PATH);
              await octokit.repos.uploadReleaseAsset({
                owner: TARGET_OWNER,
                repo: TARGET_REPO,
                release_id: release.data.id,
                name: ASSET_PATH.split('/').pop(),  // 提取文件名
                data: fileContent,
                headers: {
                  'content-type': 'application/zip',
                  'content-length': fileContent.length
                }
              });
              console.log("✅ 跨仓库同步成功！");
            } catch (err) {
              core.setFailed(`资产上传失败：${err.message}`);
            }
